% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/query.R
\name{dollar_names}
\alias{dollar_names}
\alias{dollar_name}
\alias{wrap}
\alias{unwrap}
\alias{is_wrapper}
\alias{print.wrapper}
\alias{.DollarNames.wrapper}
\alias{$.wrapper}
\alias{dollar_names.wrapper}
\alias{dollar_name.wrapper}
\alias{dollar_names.default}
\alias{dollar_name.default}
\title{Dollar-name interceptors. Wrappers.}
\usage{
dollar_names(x, pattern = "")

dollar_name(x, n)

wrap(x)

unwrap(x)

is_wrapper(x)

\method{print}{wrapper}(x)

\method{.DollarNames}{wrapper}(x, pattern = "")

\method{$}{wrapper}(x, i)

\method{dollar_names}{wrapper}(x, pattern = "")

\method{dollar_name}{wrapper}(x, i)

\method{dollar_names}{default}(x, pattern = "")

\method{dollar_name}{default}(x, i)
}
\description{
In the process of building a query, a number of objects of different
classes are involved. In order to avoid defining multiple \code{$} operator
methods and multiple \code{.DollarName} methods, we define and export only
the pair of methods for the \code{wrapper} class. These methods pass the
control to \code{dollar_name} and \code{dollar_names} generics, respectively.
These, in turn, \code{unwrap} the actual object \code{o} and pass control to the
\code{dollar_name} or \code{dollar_names} method for that object \code{o}.

\code{wrap} puts \code{x} in a list and sets that list's class
to \code{"wrapper"}.

\code{unwrap} returns the original wrapped object.
}
\details{
This way we:
\itemize{
\item avoid the risk of defining and injecting the \code{$} operator method
into unexpected places, especially other packages
\item expose explicit testing API
}
}
