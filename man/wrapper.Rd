% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/wrapper.R
\name{wrapper}
\alias{wrapper}
\alias{wrap}
\alias{unwrap}
\alias{is_wrapper}
\alias{print.wrapper}
\alias{.DollarNames.wrapper}
\alias{$.wrapper}
\alias{dollar_names}
\alias{dollar_name}
\alias{dollar_names.wrapper}
\alias{dollar_name.wrapper}
\alias{dollar_names.default}
\alias{dollar_name.default}
\title{Wrapper and dollar-name interceptors.}
\usage{
wrap(x)

unwrap(x)

is_wrapper(x)

\method{print}{wrapper}(x)

\method{.DollarNames}{wrapper}(x, pattern = "")

\method{$}{wrapper}(x, i)

dollar_names(x, pattern = "")

dollar_name(x, n)

\method{dollar_names}{wrapper}(x, pattern = "")

\method{dollar_name}{wrapper}(x, i)

\method{dollar_names}{default}(x, pattern = "")

\method{dollar_name}{default}(x, i)
}
\description{
In order to separate the user-facing API from the testable code that
implements user-facing API, all user-facing S3 classes are always
wrapped in the \code{"wrapper"} class. Moreover, instead of overloading
the \code{$} operator and the \code{.DollarNames} method for all these
user-facing classes, a \code{dollar_name} and \code{dollar_names} S3 methods
are introduced. They have the exact same semantics. This way, in the
test code, the \code{$} operator can be used to access actual data and
clearly distinguished from the tab-completion mechanism for the end
user.

\code{wrap} puts \code{x} in a list and sets that list's class
to \code{"wrapper"}.

\code{unwrap} returns the original wrapped object.

\code{print.wrapper} calls the actual \code{print} method for the
unwrapped object.

the \code{.DollarNames} method and the \code{$} operator are the
only user-facing entry points into the tab-completion mechanism.

\code{dollar_names} is an equivalent of \code{.DollarNames} and
\code{dollar_name} is an equivalent of the \code{$} operator. All S3 classes
that are publicly exposed via the \code{"wrapper"} class need to define
their own version of these two methods to enable tab completion.
}
